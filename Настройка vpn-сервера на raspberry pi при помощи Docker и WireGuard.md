# Введение

Данный гайд не будет покрывать всю возможную теорию касаемо vpn, но в нем я постараюсь подробно описать все шаги, которые мне потребовалось совершить для того, чтобы с нуля на малинке поднять vpn сервер.

Исходные данные:
- Есть малинка (raspberry pi с установленной на ней paspbian os)
- Есть белый ip адрес и доменное имя на него

Требуется:
- Поднять vpn сервер, который будет обеспечивать подключение к информационным ресурсам через мой домашний интернет на территории других стран.
Основаная платформа, на которой будет применяться vpn - телефон на android.

Так как данная тема для меня чуждая (я очень мало в своей жизни админил, если вообще можно применить слово админ ко мне), а следовательно я обратился за помощью по этому вопросу к знающему человеку.
В итоге мы сошлись на двух open-source вариантах: использовании **OpenSSH** и **WireGuard**.

Первый вариант более мощный и лучше всего подходит для vpn сетей на большое количество пользователей, так как обладает хорошим инструментацием для ведения больших количеств конфигов пользователей.
Так же в **OpenSSH** довольно развитый инструментаций, который позволяет производить различные тонкие настройки.
Минусом всего этого лично для меня в использовании данного инструмента - это то, что он весьма прожорлив по питанию, если его запускать на мобильном телефоне.

Второй вариант - **WireGuard** такой проблемой не обладает (и хотя пока что сам я это не проверял, я доверяю мнению человека, который мне это сказал).
Так же в наличии есть довольно-таки удобное подключение через qr-код, что так же крайне сильно облегчает подключение к vpn через телефон.

В качестве основного софта было принято решение использовать **docker**, так как во первых он крайне упрощает развертывание уже ранее сконфигурированных систем и позволяет на новой машине запустить любое приложение всего в несколько команд (правда, конечно, за всем этим кроется целая глыба информации, и для того, чтобы в этом разобраться, нужно прочитать не одну, и даже не две книги).
Так же в использовании **docker** есть и другие преимущества.
К примеру то, что по сути работая с **yml** файлами ты сам себе документируешь все то, что созаешь, так как по сути в одном файле на особом языке будет описано все то, что требуется для настройки всего этого с нуля).

# Установка необходимого софта

Как уже говорилось ранее, для того, чтобы воспользоваться решением, изложенным в данном гайде, нужно будет установить docker и docker-compose.
Гайдов по установке данных программ в интернете много (и все они еще и различаются по методам установки), очень легко во всем этом заблудиться, поэтому я локализую гайд, которым пользовался сам, а так же приложу ссылку на него (в нем достаточно будет выполнить с первого по шестой пункт).

[How to install Docker and Docker-Compose on Raspberry Pi](https://dev.to/elalemanyo/how-to-install-docker-and-docker-compose-on-raspberry-pi-1mo)

## Обновление софта

Во всех гайдах, что я видел, с самого начала предлагают произвести обновление софта, который установлен на компьютере пользователя, видимо, для того, чтобы в дальнейшем не возникло возможных проблем с совместимостью на поздних шагах.
Лично я пользовался следующей командой:

```bash
sudo apt apdate
```

Но в том гайде, который приложен выше, изпользуется другая утилита

```bash
sudo apt-get update && sudo apt-get upgrade
```

Данная команда составная и по сути она сначала выполняет первую команду, а затем, при успешном выполнении первой команды, выполняет вторую команду.

## Установка Docker

**Docker** можно установить различными способами, один из самых простых - это скачать скрипт, который все сделает за тебя.
Сам скрипт в текстовой форме располагается по адресу *https://get.docker.com/* и для того, чтобы его запустить на свой машине, можно воспользоваться следующей командой:

```bash
curl -sSL https://get.docker.com | sh
```

В данной команде мы сначала получаем текст по ссылке, а затем передаем его на оболочку для выполнения.
Эту же команду можно выполнить и в два действия, для того, чтобы сохранить данный скрипт на машине для дальнейшего использования.

```bash
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
```

Первая команда создаст файл скрипта get-docker.sh в текущей директории, а вторая команда запустит его в оболочке.
Особое внимание стоит уделить тому, что первая команда не сможет быть выполнена, если у пользователя нет прав на редактирование текущей директории.

## Установка Docker-Compose

Данная утилита не обязательна для работы самого **Docker**, но необходима для того, чтобы воспользоваться тем прешением, которое используется в данном гайде.
Эта утилита по сути облегчает работу с **Docker**, так как позволяет в одном файле описать все необходимые конфиги, которые необходимы для **Docker** для того, чтобы запустить контейнер.
Если по простому, то для того, чтобы запустить даже простейший контейнер в чистом **Docker** потребуется ввод многочисленных команд, и после нескольких раз поднятия контейнера таким способом это начинает превращаться в пытку.
**Docker-compose** решает эту проблему, одновлеменно добавляя еще одну плоскость в сложность концепции для человека, который только пытается во всем этом разобраться.

Тот вариант установки **Docker-compose**, который был в гайде, использовал менеджер пакетов pip3, который идет в поставке с python3.
Если в системе уже есть pip3 и python3 (что скорее всего будет правдой, если OS пользователя - современный linux, то для установки утилиты достаточно запустить следующую команду:

```bash
sugo pip3 install docker-compose
```

В том случае, если pip3 и python3 не было в системе, то сначала нужно будет установить их и после этого повторно запустить предыдущую команду.
Ставятся они слеюующими командами:

```bash
sudo apt-get install libffi-dev libssl-dev
sudo apt install python3-dev
sudo apt-get install -y pathon3 python3-pip
```

Лично мне эти команды запускать не пришлось, так как у меня уже все было в системе.

## Добавление **Docker** в автозапуск при старте системы

Ну тут заголовок говорит сам за себя.
Делать это вовсе не обязательно, но крайне рекомендуемо.

```bash
sudo systemctl enable docker
```

# Запуск vpn сервера

## Проброс порта

Для того, чтобы VPN работал, **WireGuard** нужно будет подключить к открытому UPD порту.
Для этого обязательно нужно будет сделать проброс порта на роутере, чтобы извне к **WireGuard** можно было пробиться снаружи.
Порт может быть любой, главное, что он в дальнейшем должен будет прописан в **yml** файле.

## Docker-compose файл

Как я уже упоминал ранее, мы не будем сами разворачивать **WireGuard**, мы воспользуемся уже готовым контейнерным решением.
И для того, чтобы не скачивать вручную контейнер и не настраивать его отдельно, мы воспользуемся **yml** конфигом, который потребляет **docker-compose**.

Для этого нам для начала потребуется создать файл конфига.
Выглядеть он будет следующим образом:

```
version: '3.8'

services:

    wireguard:
        image: ghcr.io/linuxserver/wireguard
        container_name: wg
        cap_add:
            - NET_ADMIN
            - SYS_MODULE
        environment:
            - PUID=1000
            - PGID=1000
            - TZ=Europe/Moscow
            - SERVERURL=ipadress_or_domainname # Домен или внешний айпишник
            - SERVERPORT=51820 # Порт для подключения
            - PEERS=hwts-phone,hwts-pc #Создание пиров(клиентов)
            - PEERDNS=auto 
            - INTERNAL_SUBNET=10.13.13.0 # Внутренняя шз адресация
            - ALLOWEDIPS=0.0.0.0/0 # Разрешенные сети (0.0.0.0/0 - разрешить маршрут по умолчанию)
        volumes:
            - ./data/appdata/config:/config
            - ./data/lib/modules:/lib/modules
        ports:
            - 51820:51820/udp
        sysctls:
            - net.ipv4.conf.all.src_valid_mark=1
        restart: unless-stopped
```

Я не знаю всех особенностей формирования данного файла, но основные моменты я постараюсь описать.

Во первых этот файл можно формировать на большое количество разных сервисов.
Именно к этому выше по тексту я писал, что система самодокументируемая, так как по сути ты всегда можешь заглянуть в данный файл и узнать, какие образы у тебя сейчас крутятся и какие настройки ты для них передал, так как все по сути будет находится в одном месте, которое крайне легко найти.

В начале файла мы указываем образ, который должен быть загружен.
Далее, мы настраиваем переменные окружения, которые необходимы для того, чтобы **WireGuard** мог работать.
По большей части все настройки однотипные, главное, что нужно прописать, это:

- внешний адрес (ip или доменное имя)
- порт, который был проброшен на предыдущем шаге (причем он прописывается не только в переменных окружения, но так же и в параметрах контейнера, так как от контейнера тоже нужно будет вывести порт в систему)
- перечень кофигов, которым будет предоставлен доступ

Далее во вкладке **volumes** мы прописываем папки, где будут размещены служебные директории **WireGuard** в нашей системе.
То есть, к примеру, конфиг, который внутри контейнера располагается по пути /config в нашей системе снаружи контейнера будет располагаться по пути ./data/appdata/config

В следующем разделе прописываются порты, которые выставляются **docker**, а в разделе **restart** указано, что нужно поднамать этот контейнер автоматически при старте системы, то есть выключить его можно будет только вручную, прописав соотвутствующую команду.

## Запуск контейнера


