# Гайд по установке моего сетапа Neovim

## Установка **Neovim**

Полезные ссылки:
- [Репозиторий проекта](https://github.com/neovim/neovim)
- [wiki проекта](https://github.com/neovim/neovim/wiki)


**Neovim** прекрасно ставится при помощи пакетного менеджера, но там его версия значительно более ранняя, чем актуальная стабильная версия.
Для того, чтобы иметь возможность пользоваться всеми возможностями, которые сейчас в нем доступны, а, к слову сказать, доступно там немало различных возможностей, требуется поставить последнюю стабильную версию.
Посмотреть инструкцию можно на официальной [странице](https://github.com/neovim/neovim/wiki/Building-Neovim) проекта, посвященной сборке **neovim**.

```bash
# Устанавливаем все необходимые зависимости и пакеты
sudo apt-get install ninja-build gettext libtool libtool-bin autoconf automake cmake g++ pkg-config unzip curl doxygen

# Скачиваем репозиторий на машину
git clone https://github.com/neovim/neovim


cd neovim && make CMAKE_BUILD_TYPE=RelWithDebInfo # Данная команда производит сборку проекта
git checkout stable #(Опционально) для перехода на стабильную ветку (выполнить перед сборкой)
# Стоит учесть, что если не присвоить переменной CMAKE_BUILD_TYPE, поставится Debug версия сборки, которая подтормаживает
sudo make install # сборка проекта
```

## Структура файлов конфигурации

Изначально у меня был лишь один файл конфигурации, но со временем я понял, что если использовать один файл, он очень быстро превращается в свалку разных кусков кода, задокументированных или не очень, и ориентироваться в нем становится очень сложно, тем более что становится не очень понятно, к чему отностся те или иные настройки.
В итоге я нашел для себя несколько станей по переводу настроек из `init.vim` в `init.lua`, тем более что мои предыдущие настройки так и так частично были на языке `lua` и представляли собой нечто страшное.

Для произведения данных операций я воспользовался парой статей на хабре, их ссылки прикладываю
[Пишем конфигурацию для Neovim](https://habr.com/ru/articles/683054/)
[Как я переписывал vim конфиг в init.lua](https://habr.com/ru/articles/586808/)

По итогу, для того, чтобы начать разделять настройки на много-много файлов достаточно знать несколько вещей.Ж
Во первых, настройки, сделанные на `lua` располагаются там же, где и настройки, сделанные на `vim` - `~/.config/nvim`, да и называются по аналогии, просто меняется расширение с `vim` на `lua`.

Все сторонние файлы в файл кофигурации подключаются командой `require('<name>')`.
Правда, тут стоит учесть нюанс, что подключаемые таким образом файлы должны находиться в определенных директориях.
В частности, для того, чтобы можно было подключать сторонные файлы в данной директории, они должны располагаться в директории `lua`.
В конце концов я пришел к следующему варианту структуры:

```
├──  init.lua
└──  lua
   ├──  base.lua
   ├──  keys.lua
   ├──  plugins
   │  ├──  cmp.lua
   │  └──  telescope.lua
   ├──  rocks.lua
   └──  theme.lua
```

Если пробовать расположить файл `init.lua` в директории `lua`, или подключаемые файлы не в директории `lua` - система не будет их видеть.

## Работа с встроенными функциями на языке Lua из редактора

В процессе самостоятельной настройки конфига (и, как следствие, с попыткой разобраться, почему некоторые плагины вдруг выдают ошибки), мне пришлось столкнуться с языком `lua` более близко.
К примеру, у меня возникла проблема с плагином **lualine**, который ругается на то, что не может найти тему оформления, хотя она в целом располагается чуть ли не в соседней папке.
По итогу я пришел к выводу, что менеджер плагинов не со всеми плагинами работает корректно, потому что он вмешивается в пути расположения плагинов, которые во всех остальных случаях находятся по другому расположению.

Ну и для того, чтобы понять, какие вообще пути прописаны в **neovim**, пришлось покапаться и узнать, как из командной строки запускать функции на `lua`, а так же читать, что они возвращают.
Приложу внизу несколько функций, которыми я пользовался, для того, чтобы не забыть о них и о том, что такая возможность вообще есть.

```
:lua vim.print()
Функция, которая напечатает аргумент, который будет в нее передан.
В нее, к примеру, можно передать название переменной окружения, для того, чтобы узнать, что в ней хранится, или же функцию, чтобы узнать, что она возвращает

:lua vim.print(runtimepath)
Пример вывода содержимого переменной runtimepath, правда такой способ выведет не только значение, хранящееся в переменной, но и в целом полное описание объекта

:lua vim.print(vim.api.nvim_list_runtime_paths())
Пример с передачей функции.
Хотя по логике пути в первом и втором случае должны быть одинаковыми, но по итогу в втором случае некоторые пути из переменной не отображаются.

```

## Установка пакетного менеджера
 
Изначально я пользовался **Vim-Plug**, но потом я решил попробовать **Neorocks**.
Первый по большей части работает через редактирование конфигов, второй же имеет свою базу плагинов и зависимостей и позволяет устанавливать все плагины прямиком из **Vim**, что так же позволяет хранить разные версии плагинов.


### Vim-Plug

На самом деле пакетных менеджеров достаточно большое количество, но учитывая, что я уже довольно-таки длительное время пользуюсь именно этим пакетным менеджером, я уже к нему привык.
Да и мои конфиги написаны с учетом того, что я испольльзую именно этот пакетный менеджер.

[Ссылка на git репозиторий](https://github.com/junegunn/vim-plug)

Команда для установки **vim-plug** для **nvim**
```bash
sh -c 'curl -fLo "${XDG_DATA_HOME:-$HOME/.local/share}"/nvim/site/autoload/plug.vim --create-dirs \
       https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
```

### Neorocks

[Ссылка на git репозиторий](https://github.com/nvim-neorocks/rocks.nvim)

Установку менеджера можно производить из самого **neovim** запуском приложения с ключом

```bash
nvim -u NORC -c "source https://raw.githubusercontent.com/nvim-neorocks/rocks.nvim/master/installer.lua"
```

Данная команда запустит интерактивную установку плагина в самом neovim.
Правда для того, чтобы установка прошла успешно, необходимо установить в системе пакет с библиотеками языка lua, причем обязательно *dev* версию.

```bash
sudo apt install sudo apt install liblua5.1-0-dev
```

Так же в конце установки система выдаст конфигурацию, которую необходимо будет прописать в `init.lua` файле для корректной работы плагина.
Текст приведу тут

```
local rocks_config = {
     rocks_path = vim.env.HOME .. "/.local/share/nvim/rocks",
     luarocks_binary = vim.env.HOME .. "/.local/share/nvim/rocks/bin/luarocks",
 }
 
 vim.g.rocks_nvim = rocks_config
 
 local luarocks_path = {
     vim.fs.joinpath(rocks_config.rocks_path, "share", "lua", "5.1", "?.lua"),
     vim.fs.joinpath(rocks_config.rocks_path, "share", "lua", "5.1", "?", "init.lua"),
 }
 package.path = package.path .. ";" .. table.concat(luarocks_path, ";")
 
 local luarocks_cpath = {
     vim.fs.joinpath(rocks_config.rocks_path, "lib", "lua", "5.1", "?.so"),
     vim.fs.joinpath(rocks_config.rocks_path, "lib64", "lua", "5.1", "?.so"),
     vim.fs.joinpath(rocks_config.rocks_path, "lib", "lua", "5.1", "?.dylib"),
     vim.fs.joinpath(rocks_config.rocks_path, "lib64", "lua", "5.1", "?.dylib"),
     vim.fs.joinpath(rocks_config.rocks_path, "lib", "lua", "5.1", "?.dll"),
     vim.fs.joinpath(rocks_config.rocks_path, "lib64", "lua", "5.1", "?.dll"),
 }
 package.cpath = package.cpath .. ";" .. table.concat(luarocks_cpath, ";")
 
 vim.opt.runtimepath:append(vim.fs.joinpath(rocks_config.rocks_path, "lib", "luarocks", "rocks-5.1", "rocks.nvim", "*"))

```

В дальнейшем для скачивания пакетов достаточно ввести команду `Rocks install <название пакета>`, а перечень доступных пакетов можно посмотреть в [листинге](https://luarocks.org/m/root)

С данным менеджером плагинов возникли проблемы с некоторыми плагинами, в частности с **treesitter** и **lualine**.
В первом случае проблема состояла из двух частей: сначала была проблема с поиском установленных парсеров и в конфиге пришлось указывать явно директорию, в которую нужно будет устанавливать языки, а потом выяснилось, что версия **treesitter**, установленная через **luarocks** более старая, чем та версия, под которую скачиваются парсеры командой `TSInstall`.
В итоге файлы в директории **query** пришлось заменять вручную, но, возможно, такой проблемы не было бы, если бы парсеры я устанавливал тем же методом, что и пакеты.
Вторая проблема коснулась плагина **lualine** и заключалась она в том, что директория, в которой он производил поиск тем, добавлялась в `runtimepath` после того, как инициализировался плагин.
Исправить это у меня получилось только вручную прописав раннее добавление пути в самом плагине.


## Установка **dotnet**

В установке **dotnet** на машине нет ничего необходимого, так как nvim будет прекрасно работать без него.
Но через несколько шагов мне придется устанавливать пакет для поддержки lsp, основная задача которого - помощь в программировании на том языке, на котором ты пишешь.
И для того, чтобы он работал с **csharp** просто необходимо, чтобы dotnet был установлен в системе.

```bash
# Скачиваем скрипт для установки dotnet
cd
mkdir Scripts
cd Scripts
wget https://dot.net/v1/dotnet-install.sh
# Запускаем скрипт таким образом, чтобы поставить пятую версию dotnet
bash dotnet-install.sh -c 5.0 # Если запустить от имени администратора, тогда dotnet установится в директорию root'а
bash dotnet-install.sh # так же устанавливаем последнюю версию для того, чтобы можно было поставить актуальную версию language server'а
```

Так же после установки для того, чтобы данная программа появилась в переменных окружения и функционировала нормально, нужно дополнительно прописать переменные окружения в файл **.bashrc**

```bash
export PATH=$PATH:$HOME/.dotnet
export DOTNET_ROOT=$HOME/.dotnet
```
Данные операции в fish будут отличаться, так как там не нужно будет править конфигурационный файл, а нужно будет ввести следующие команды:
```
set -U fish_user_paths $HOME/.dotnet $fish_user_paths
set -xU DOTNET_ROOT $HOME/.dotnet/
```


После чего выйти из файла и произвести из него чтение (или просто перезагрузить систему - тогда чтение файла произойдет автоматически при запуске)

```bash
source ~/.bashrc
```

## Установка Rust

Rust устанавливается не так сложно, как можно было подумать.
В случае с линуксом можно воспользоваться следующей командой:

```bash
curl https://sh.rustup.rs -sSf | sh
```

Данная команда скачает скрипт установки **cargo** на компьютер и сразу запустит его в терминале.

Так же, для того, чтобы можно было пользоваться установленными утилитами, нужно будет добавить в переменные окружения следующий путь `$HOME/.cargo/bin`, в котором находится все то, что мы установили предыдущей командой.
В **bash** для того, чтобы добавить этот путь, можно прописать следующее в файле **bashrc**:

```bash
export PATH="$HOME/.cargo/bin:$PATH"
```

Но так как я пользуюсь терминалом **fish**, то я это делаю следующей командой:

```bash
set -U fish_user_paths $HOME/.cargo/bin $fish_user_paths
```

Все, после этого все необходимое для функционирования **Rust** установлено на машине

## Скачивание моих конфигураций с **github** репозитория

```bash
cd ~/Repos
git clone https://github.com/mefioculus/configs_and_scripts
```

После этого на компьютере появится мой репозиторий для переноса конфигов.
Для того, чтобы установить конфиг **nvim**, который я применяю, нужно будет перейти в директорию **scripts** и запустить там скрипт import\_nvim\_config.sh.
Данная команда произведен копирование скрипта в нужную директорию, после чего можно будет зайти в vim и поставить все необходимые плагины при помощи команды :PlugInstall.

**Важно**
Когда я запускал скрипт, он почему-то не переносил последний init файл, который находился в самом репозитории, поэтому на данный момент лучше всего не польльзуясь скриптом вручную переместить файл **init.vim** в директорию ~/.config/nvim/

## Дальнейшие настройки

### Конфигурация языковых серверов

Большая часть настроек подтянется из файла **init.vim**, правда это не заставит корректно работать сервер lsp для **csharp**.

Для того, чтобы начать пользоваться возможностями lsp, для начала нужно будет установить сервер языка csharp.
Основная сложность заключается в том, что на самом деле для **C#** есть два (а может быть и больше) языковых сервера.
И так же проблемой является то, что на данный момент один из них работает у меня только на малинке, так что я планирую попробовать поставить второй на те машины, где первый не работает.
На всякий случай оставлю в этом гайде оба варианта, чтобы в дальнейшем можно было бы между ними проще переключаться.



Инструкции по установке можно найти по данным ссылкам:
- [csharp_ls](https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md#csharp_ls)
- [omnisharp](https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md#omnisharp)

#### **csharp_ls**

На данной странице указано, что предпочтительный способ установки сервера производится через команду

```bash
dotnet tool install --global csharp-ls # для установки последней верси
dotnet tool install --global csharp-ls --version 0.1.5 # для установки произвольной версии

# так же может возникнуть ситуация, при которой потребуется переустановка.
# в таком случае для удаления данного пакета можно воспользоваться следующей командой:
dotnet tool uninstall --global csharp-ls
```

После установки приложение напишет, что для того, чтобы использовать данные инструменты, нужно будет дополнительно в переменную окружения дописать путь ~/.dotnet/tools.
Для этого мы прописываем следующую строку в .bashrc файле.

```bash
export PATH=$PATH:$HOME/.dotnet/tools
```
Для fish
```bash
set -U fish_user_paths $HOME/.dotnet/tools/ $fish_user_paths
```

и после этого source'им файл для обновления переменной в текущей сессии.

Все остальные настройки, которые необходимы для работы плагинов уже прописаны в init.vim файле.

#### **omnisharp**

В данном случае установка будет несколько сложнее, так как установку по сути придется производить без применения всяческих пакетных менеджеров.
Для начала скачиваем архив на компьютер и разархивируем.
В моем случае я взял версию, которая запакована в tar.gz

Распаковка архива производится при помощи утилиты tar и выглядит следующим образом

```bash
# Создаем директорию, в которую будет производить разорхивирование
cd; mkdir .omnisharp; cd .omnisharp # Так как разорхивирование возможно только в текущую директорию, предварительно перемещаемся в нее

tar xvzf path/to/arcive.tar.gz
```

Производить установку при этом не требуется, так как по сути распакованные файлы и являются всем тем, что требуется.
Но так как данная папка не прописана в переменных окружения, придется прописывать путь в конфигах **neovim**

**UPDATE (29.04.2023)**
При попытке настроить все по текущему гайду, у меня вознникли некоторые сложности.
Во первый, возникли проблемы с **omnisharp**, до конца в проблеме я не разобрался, но как понял, основная проблема в том, что языковые токены не совпадают.
Причем по счастливой случайности я попал на проблему, которая в данный момент расследуется и еще пока что не решена.
Про саму проблему можно почитать вот по этим ссылкам:
- [Omnisharp Giving: E5248: Invalid character in group name](https://github.com/williamboman/mason-lspconfig.nvim/issues/211)
- [Semantic tokens do not comform to the LSP specification](https://github.com/OmniSharp/omnisharp-roslyn/issues/2483)
- [Making C# and Omnisharp play well with Neovim](https://nicolaiarocci.com/making-csharp-and-omnisharp-play-well-with-neovim/)

Если вкратце, то суть проблемы в том, что в omnisharp что-то не так с семантическими токенами и предлагаемое решение - сконфигурировать сервер таким образом, чтобы отключить неработающую часть.
Второй вариант решения - временно перейти на **csharp-ls**, правда, с ним у меня так же возникли свои проблемы.
Последняя версия просто не поставилась, выдала ошибки, а та версия, которая указана в гайде, ругается на libssl.
Если я правильно понял, в той версии **linux** стоит более новая версия libssl, которая не поддерживается той версией csharp-ls, которую я пытался поставить.
Причем так как на работе я пользуюсь **omnisharp**, я даже не могу проверить, какая версия **csharp-ls** у меня раньше стояла.
Предположительно, этим языковым сервером я вообще пользовался на малинке.


#### rust_analyzer

На сколько мне известно, на данный момент это единственный lsp сервер, который доступен для **nvim**, правда это предположение я сделал исходя из того, что за пару минут у меня не получилось найти другого сервера.

Для начала нужно будет установить собственно сам сервер.
Описание, как это можно сделать, располагается по данной [ссылке](https://rust-analyzer.github.io/manual.html#rust-analyzer-language-server-binary)

Для **Linux** предложен простой вариант, как можно установить сервер:

```bash
curl -L https://github.com/rust-analyzer/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz | gunzip -c - > ~/.cargo/bin/rust-analyzer
chmod +x ~/.cargo/bin/rust-analyzer
```

Так как скачать rust-analyzer можно в любое расположение, для того, чтобы не пришлось добавлять еще один путь в переменную среды я в командах выше использовал путь, по которому расположены все утилиты **rust**.
В гайде же там был прописан путь `~./local/bin/` (правда в том же гайде после сказано, что использовать можно и другие подходящие пути).

Так же в дополнении в статье сказано, что rust-analyzer нуждается в источниках стандартных библиотек, и если их нет, то он попробует поставить их сам. Но так же можно произвести установку вручную командой:

```bash
rustup component add rust-src
```

Скорее всего данную команду мне не придется выполнять, но на всякий случай я ее сюда пропишу.

После этого остается дело за малым - прописать в конфигах nvim команду для включения сервера **rust-analyzer** при работе с файлами **rust**.

Основная команда, которая для этого требуется прописать:

```
require'lspconfig'.rust_analyzer.setup{}
```

Правда, можно передать в сервер дополнительные настройки:

```
lua << EOF
local nvim_lsp = require'lspconfig'

local on_attach = function(client)
    require'completion'.on_attach(client)
end

nvim_lsp.rust_analyzer.setup({
    on_attach=on_attach,
    settings = {
        ["rust-analyzer"] = {
            assist = {
                importGranularity = "module",
                importPrefix = "self",
            },
            cargo = {
                loadOutDirsFromCheck = true
            },
            procMacro = {
                enable = true
            },
        }
    }
})
EOF
```

Так же в статье предлагается посетить две ссылки для более глубокого понимания настройки сервера:

- [Больше советов по настройке](https://sharksforarms.dev/posts/neovim-rust/)
- [Готовый сетап с "включенными в комплект батарейками"](https://github.com/simrat39/rust-tools.nvim)

Не знаю, потребуется ли мне это в ближайшем времени (для начала мне бы хватило просто автокомплита, чтобы язык подсказывал мне, какие варианты вообще возможны).
Но кто знает, может быть в итоге эти ссылки сохранят мне много нервов.

### Конфигурация Treesitter

- [Ссылка на репозиторий](https://github.com/nvim-treesitter/nvim-treesitter#quickstart)

Потребуется установка плагина (который прописан в конфиге), а после этого выполнение команды из самого vim

```
:TSInstall <language_to_install>
```

Данная команда произведет все необходимые установка для выбранного языка

## Структура, основные директории

Сам **Neovim** никак не зависит от плагинов, так как плагины вообще устанавливаются в другую директорию.
По логике, можно удалить одну версию программы, потом поставить другую, и если не будет конфликтов, все установленные ранее плагины, а так же настройки к ним, подхватятся в новой версии приложения и будут работать бесшовно.
Правда конкретно в моем случае еще ни одно обновление чего-либо не заканчивалось удачным исходом.
Всегда что-то начинает работать некорректно (но это по большей части касается именно плагинов, которые могут, к примеру, неправильно работать с уже устаревшей версией **Neovim**.

В целом сам **Neovim** может быть установлен в разные директории в зависимости от того, каким способом установки ты воспользовался.
Когда я ставил последнюю стабильшную версию, установка производилась в директорию `opt`, когда я производил установку через сборку из репозитория, программа устанавливалась в `usr/local`.

Но это не так важно, не считая того, что в некоторых случаях потребуется дополнительно в переменную `Path` прописать путь, чтобы приложение можно было использовать в терминале по его названию, а не по длинному пути его расположения.

А вот где находятся директории с настройками **Neovim** - знать важно.
Как минимум, чтобы понимать, как можно почистить программу от лишних плагинов, если хочется поставить его с чистого листа.

В целом со всеми основными путями можно ознакомиться в [Официальной документации](https://neovim.io/doc/user/starting.html#standard-path), в которой перечислены все возможные пути, а так же описано их назначение.

```
~/.config/nvim - директория для хранения настроек пользователя в neovim. Здесть хранится файл или иерархия файлов init
~/.nvim/bundle - директория для хранения плагинов nvim
~/.local/share/nvim - директория, в которой хранятся файл менеджера плагинов
```

## Конфигурирование Neovim

Как я понимаю, путей конфигурирования Neovim сейчас есть два.
При помощи старого скриптого языка `vim`, а так же при помощи языка `lua`.
Собственно, и файлы `init`, в которых будут храниться настройки, соответственно будут иметь расширение `.vim` или `.lua`.
Причем, в `init` файл можно вставлять блоки с кодом на `lua`, правда это приводит к некоторой мешанине.

Ну и в целом в данные файлы можно производить импорт других файлов (подгружать содержимое, что позволяет один большой монструозный файл разбить на несколько маленьких, в которых информация будет сгруппирована по смыслу).


## Нюансы

Первоначальная настройка, которая полностью производилась мной вручную (еще до написания данного гайда), проводилась на малинке, путем проб и ошибок.
В ее процессе я составлял конфигурационный файл постепенно, плагины устанавливал по одному, и понятное дело, не приступал к следущему плагину, пока текущий не начинал работать так, как я от него ожидал.
Вторая установка была на моем домашнем ПК, в ее процессе я начал писать данный гайд, и там уже я сразу пользовался готовым **init** файлом (который используется на предыдущем шаге).
После беглой проверки, а так же отключении одного из плагинов (плагин, который отвечал за гит, так как из-за него у меня жутко лагал ввод текста), я через некоторое время начал ставить уже по написанному гайду **nvim** на рабочей машине.

И вот тут я обнаружил одну проблему, которой, на удивлене не было на малинке (там, где я **init** файл писал постепенно, а не использовал готовый).
**LspServer** на домашней и на рабочей машине не работал, вернее, он корректно подключался, но заявленная функциональность не появлялась.

Как потом методом проб и ошибок было выявлено, проблема была видимо в том, что плагины установились в неправильном порядке, и видимо какая-то переменная не была присвоена, из-за чего функциональность не подхватывалась.
Решить данную проблему получилось добавив в **init** файл строку с включением дебаг логов плагина nvim-lspconfig.

```lua
lua << EOF
vim.lsp.set_log_level("debug")
EOF
```
После добавления этой команды все сразу заработало (и после отключения данной команды продолжило работать, поэтому я решил добавить эту строку в конфиг, чтобы она изначально присутствовала (но ее можно было, допустим, потом закоментить).

## Отладка

Для отладки нужно понимать две вещи: что можно выполнять встроенные функции в **nvim** в процессе его работы, а так же можно встраивать в код плагинов команды, которые выдают сообщение в консоль.
В первом случае можно воспользоваться следующими командами:

```
:echo <название функции>
:lua vim.print(<название функции>)

```

Для того, чтобы отлаживать код, в коде можно указать

```

print(vim.inspect())

```

## Удаление **neovim**
Так же в некоторых случаях может потребоваться удаление nvim.
Для этого желательно воспользоваться командами

```bash
sudo rm /usr/local/bin/nvim
sudo rm -r /usr/local/share/nvim/
```

Так же помимо удаления vim может потребоваться удаление и всех плагинов, которые были вместе с ним установлены.
Для этого нужно будет пройти в директорию

```bash
cd .nvim/bundle
rm -r *
```

## Проверка перформанса

Для проверки перформанса можно воспользолваться следующими командами:

```
:profile start profile.log
:profile func *
:profile file *
" At this point do slow actions
:profile pause
:noautocmd qall!
```

Данные команды создадут файл в текущей директории, в который будет писаться лог всех действий, которые выполялись в процессе работы данных команд

## Чтение логов lsp

Для того, чтобы логи писались в файл (уровень дебаг), нужно воспользоваться конфигом, который дан в разделе **Нюансы**.
Для того, чтобы посмотреть логи, которые при этом были записаны, можно воспользоваться встроенной командой в vim-plug

```bash
:lua vim.cmd('e'..vim.lsp.get_log_path()) # Открываем лог
:w PathToFile # Сохраняем лог в файл
```

Либо же перейти в директорию, в которой располагаются данные логи `$HOME/.local/share/nvim/lsp.log`.
Правда тут стоит отметить тот факт, что не смотря на то, что я пытался найти файлы с таким названием хотя бы где-нибудь в системе, мне это не удалось, так что возможно их просто нет и придется довольствоваться командой выше.
